<?php
/*   __________________________________________________
    |  		Code By HauN - HauNYTB.COM  2.0.14    	  |
    |          Telegram: https://t.me/haunytb         |
    |    	   Url : https://haunytb.com    		  |
    |_________________________________________________|
*/
 namespace HNMG\Directives; use Illuminate\Support\Collection; use Illuminate\Support\Facades\Blade; use Illuminate\Support\Str; use HNMG\Contracts\Directives as DirectivesContract; abstract class Directives implements DirectivesContract { protected bool $registered = false; protected array $conflicts = []; public static function make() : self { return new static(); } public function register() : void { goto J_kdB; J_kdB: if (!$this->registered) { goto lqS9r; } goto EB9o9; ls_k8: $conflicts = collect($this->conflicts)->filter(fn($directives, $class) => class_exists($class))->flatMap(fn($directives) => (array) $directives); goto ZdbGt; ZdbGt: collect($this->directives())->except($conflicts)->each(fn($callback, $directive) => Blade::directive($directive, $callback)); goto k01dG; EB9o9: return; goto SA4MA; SA4MA: lqS9r: goto ls_k8; k01dG: $this->registered = true; goto pq6Lr; pq6Lr: } public function parse(string $expression, int $limit = PHP_INT_MAX, string $delimiter = "\137\137\x63\x6f\155\x6d\x61\137\137") : Collection { $expression = preg_replace_callback("\57\47\50\x2e\x2a\x3f\x29\x27\174\x22\x28\56\x2a\77\x29\42\57", fn($matches) => str_replace("\54", $delimiter, $matches[0]), $expression); return Collection::make(explode("\x2c", $expression, $limit))->map(function ($item) use($delimiter) { $item = Str::of($item)->replace($delimiter, "\54")->trim()->toString(); return !is_numeric($item) ? $item : (int) $item; }); } public function shouldParse(?string $expression = '') : bool { return Str::contains($expression, "\54"); } public function isToken(?string $expression = '') : bool { $expression = $this->strip($expression); return !empty($expression) && (is_numeric($expression) || Str::startsWith($expression, ["\44", "\147\145\164\137"])); } public function strip(?string $expression = '', array $characters = ["\47", "\42"]) : string { return str_replace($characters, '', $expression ?? ''); } public function wrap($value) { goto jUM62; cyg1d: return $value; goto qzD4y; jUM62: $value = Str::start($value, "\47"); goto S6YRf; S6YRf: $value = Str::finish($value, "\47"); goto cyg1d; qzD4y: } public function unwrap(?string $value = '', string $delimiter = "\47") : string { goto y2azY; CBmC6: $value = Str::replaceLast($delimiter, '', $value); goto l3k6M; VFaCs: if (!Str::endsWith($value, $delimiter)) { goto tBmG8; } goto CBmC6; l3k6M: tBmG8: goto mNG2o; mNG2o: return $value; goto x63rd; mqcFK: NG0aP: goto VFaCs; amEB0: $value = Str::replaceFirst($delimiter, '', $value); goto mqcFK; y2azY: if (!Str::startsWith($value, $delimiter)) { goto NG0aP; } goto amEB0; x63rd: } public function toString(string|array|null $expression = '', bool $single = false) : string { goto SXue8; Lffal: if ($single) { goto dBo3f; } goto femGY; gIghf: q4oL9: goto cyrmj; JaYNv: $keys = Str::finish($keys, "\135"); goto EMxGn; XOK4k: return $keys; goto rO7Ow; femGY: $keys = Str::start($keys, "\x5b"); goto JaYNv; fswbz: n1858: goto OXAUS; SXue8: if (is_array($expression)) { goto n1858; } goto AVuvS; AVuvS: return $this->wrap($expression); goto fswbz; cyrmj: $keys = trim(Str::replaceLast("\54", '', $keys)); goto Lffal; RbN0o: foreach ($expression as $key => $value) { $keys .= $single ? $this->wrap($value) . "\54" : $this->wrap($key) . "\40\x3d\x3e\x20" . $this->wrap($value) . "\54\x20"; TgYsZ: } goto gIghf; OXAUS: $keys = ''; goto RbN0o; EMxGn: dBo3f: goto XOK4k; rO7Ow: } public function isArray(?string $expression = '') : bool { $expression = $this->unwrap($expression); return Str::startsWith($expression, "\x5b") && Str::endsWith($expression, "\x5d"); } }
