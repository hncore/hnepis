<?php
/*   __________________________________________________
    |  		Code By HauN - HauNYTB.COM  2.0.14    	  |
    |          Telegram: https://t.me/haunytb         |
    |    	   Url : https://haunytb.com    		  |
    |_________________________________________________|
*/
 namespace HNMG\Directives; use Illuminate\Support\Collection; use Illuminate\Support\Facades\Blade; use Illuminate\Support\Str; use HNMG\Contracts\Directives as DirectivesContract; abstract class Directives implements DirectivesContract { protected bool $registered = false; protected array $conflicts = []; public static function make() : self { return new static(); } public function register() : void { goto b8KT7; lkNxa: return; goto xpHIf; PxNuL: $conflicts = collect($this->conflicts)->filter(fn($directives, $class) => class_exists($class))->flatMap(fn($directives) => (array) $directives); goto ipa2q; ipa2q: collect($this->directives())->except($conflicts)->each(fn($callback, $directive) => Blade::directive($directive, $callback)); goto l1LbP; b8KT7: if (!$this->registered) { goto xG3NM; } goto lkNxa; l1LbP: $this->registered = true; goto XBTV4; xpHIf: xG3NM: goto PxNuL; XBTV4: } public function parse(string $expression, int $limit = PHP_INT_MAX, string $delimiter = "\x5f\x5f\143\x6f\x6d\x6d\x61\x5f\137") : Collection { $expression = preg_replace_callback("\57\47\50\x2e\52\77\x29\x27\174\x22\x28\56\x2a\x3f\51\x22\x2f", fn($matches) => str_replace("\54", $delimiter, $matches[0]), $expression); return Collection::make(explode("\x2c", $expression, $limit))->map(function ($item) use($delimiter) { $item = Str::of($item)->replace($delimiter, "\54")->trim()->toString(); return !is_numeric($item) ? $item : (int) $item; }); } public function shouldParse(?string $expression = '') : bool { return Str::contains($expression, "\54"); } public function isToken(?string $expression = '') : bool { $expression = $this->strip($expression); return !empty($expression) && (is_numeric($expression) || Str::startsWith($expression, ["\44", "\x67\145\164\x5f"])); } public function strip(?string $expression = '', array $characters = ["\x27", "\x22"]) : string { return str_replace($characters, '', $expression ?? ''); } public function wrap($value) { goto oIg8K; MxB0z: return $value; goto UNGde; etGIM: $value = Str::finish($value, "\47"); goto MxB0z; oIg8K: $value = Str::start($value, "\x27"); goto etGIM; UNGde: } public function unwrap(?string $value = '', string $delimiter = "\x27") : string { goto UhQij; uuvT6: return $value; goto laapB; fU6Oc: if (!Str::endsWith($value, $delimiter)) { goto NsO7Z; } goto ZIbvC; ooTxl: $value = Str::replaceFirst($delimiter, '', $value); goto oAgJy; i2J6x: NsO7Z: goto uuvT6; UhQij: if (!Str::startsWith($value, $delimiter)) { goto uu64j; } goto ooTxl; oAgJy: uu64j: goto fU6Oc; ZIbvC: $value = Str::replaceLast($delimiter, '', $value); goto i2J6x; laapB: } public function toString(string|array|null $expression = '', bool $single = false) : string { goto hbYWw; qNW54: return $keys; goto i0Tkq; Nfpfu: $keys = ''; goto V5jlY; sYe4L: $keys = trim(Str::replaceLast("\x2c", '', $keys)); goto yDJ0j; nodRe: $keys = Str::start($keys, "\133"); goto Jofqm; Jofqm: $keys = Str::finish($keys, "\135"); goto gdHAw; wBX5f: return $this->wrap($expression); goto PVJiv; gdHAw: ztWNv: goto qNW54; yDJ0j: if ($single) { goto ztWNv; } goto nodRe; hbYWw: if (is_array($expression)) { goto T6k3M; } goto wBX5f; V5jlY: foreach ($expression as $key => $value) { $keys .= $single ? $this->wrap($value) . "\54" : $this->wrap($key) . "\x20\75\x3e\40" . $this->wrap($value) . "\54\40"; TZrAm: } goto k626q; k626q: kaJMu: goto sYe4L; PVJiv: T6k3M: goto Nfpfu; i0Tkq: } public function isArray(?string $expression = '') : bool { $expression = $this->unwrap($expression); return Str::startsWith($expression, "\x5b") && Str::endsWith($expression, "\135"); } }
