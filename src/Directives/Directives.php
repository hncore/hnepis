<?php
/*   __________________________________________________
    |  		Code By HauN - HauNYTB.COM  2.0.14    	  |
    |          Telegram: https://t.me/haunytb         |
    |    	   Url : https://haunytb.com    		  |
    |_________________________________________________|
*/
 namespace HNMG\Directives; use Illuminate\Support\Collection; use Illuminate\Support\Facades\Blade; use Illuminate\Support\Str; use HNMG\Contracts\Directives as DirectivesContract; abstract class Directives implements DirectivesContract { protected bool $registered = false; protected array $conflicts = []; public static function make() : self { return new static(); } public function register() : void { goto ZOADc; ZOADc: if (!$this->registered) { goto tEMHf; } goto IvwWq; LD2lK: $this->registered = true; goto iYZTA; xGnAH: collect($this->directives())->except($conflicts)->each(fn($callback, $directive) => Blade::directive($directive, $callback)); goto LD2lK; rJqo0: tEMHf: goto Px5RR; Px5RR: $conflicts = collect($this->conflicts)->filter(fn($directives, $class) => class_exists($class))->flatMap(fn($directives) => (array) $directives); goto xGnAH; IvwWq: return; goto rJqo0; iYZTA: } public function parse(string $expression, int $limit = PHP_INT_MAX, string $delimiter = "\137\137\x63\x6f\x6d\155\x61\x5f\137") : Collection { $expression = preg_replace_callback("\57\x27\x28\56\52\77\x29\x27\174\x22\x28\x2e\x2a\77\x29\42\57", fn($matches) => str_replace("\x2c", $delimiter, $matches[0]), $expression); return Collection::make(explode("\54", $expression, $limit))->map(function ($item) use($delimiter) { $item = Str::of($item)->replace($delimiter, "\54")->trim()->toString(); return !is_numeric($item) ? $item : (int) $item; }); } public function shouldParse(?string $expression = '') : bool { return Str::contains($expression, "\x2c"); } public function isToken(?string $expression = '') : bool { $expression = $this->strip($expression); return !empty($expression) && (is_numeric($expression) || Str::startsWith($expression, ["\x24", "\147\x65\164\137"])); } public function strip(?string $expression = '', array $characters = ["\x27", "\42"]) : string { return str_replace($characters, '', $expression ?? ''); } public function wrap($value) { goto e0Bky; CydEV: return $value; goto rZNwn; e0Bky: $value = Str::start($value, "\47"); goto ZWufY; ZWufY: $value = Str::finish($value, "\47"); goto CydEV; rZNwn: } public function unwrap(?string $value = '', string $delimiter = "\47") : string { goto OjfJo; Jt_AQ: $value = Str::replaceLast($delimiter, '', $value); goto gTdf_; gTdf_: b3Cq2: goto UmEeC; ewzDz: ctmH_: goto Y_jWQ; OjfJo: if (!Str::startsWith($value, $delimiter)) { goto ctmH_; } goto Etbo9; Etbo9: $value = Str::replaceFirst($delimiter, '', $value); goto ewzDz; Y_jWQ: if (!Str::endsWith($value, $delimiter)) { goto b3Cq2; } goto Jt_AQ; UmEeC: return $value; goto dP5DN; dP5DN: } public function toString(string|array|null $expression = '', bool $single = false) : string { goto zP35x; lE8mx: return $this->wrap($expression); goto XGdnK; Jt4CC: $keys = Str::start($keys, "\x5b"); goto QKMTX; rLa_k: uCJip: goto DAUiV; bOt5i: yStJW: goto lZWN0; sOS6b: $keys = ''; goto V0lb3; QKMTX: $keys = Str::finish($keys, "\135"); goto rLa_k; XGdnK: HbXa2: goto sOS6b; lZWN0: $keys = trim(Str::replaceLast("\x2c", '', $keys)); goto wUUJF; V0lb3: foreach ($expression as $key => $value) { $keys .= $single ? $this->wrap($value) . "\54" : $this->wrap($key) . "\40\x3d\x3e\40" . $this->wrap($value) . "\x2c\x20"; jthm5: } goto bOt5i; wUUJF: if ($single) { goto uCJip; } goto Jt4CC; DAUiV: return $keys; goto GcVis; zP35x: if (is_array($expression)) { goto HbXa2; } goto lE8mx; GcVis: } public function isArray(?string $expression = '') : bool { $expression = $this->unwrap($expression); return Str::startsWith($expression, "\x5b") && Str::endsWith($expression, "\135"); } }
